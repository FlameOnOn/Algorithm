归并排序改进。1，可以不存数据本身，存索引，也就是存数组下标。2，归并排序，在数组长度比较短的情况下，可以
不尽兴递归，也就是不递归到底，而是选择其他排序方案，如插入排序。
基于关键字比较的排序算法的平均时间复杂度的下界为O(nlogn).
归并排序是稳定的排序，堆排序和快排是不稳定的排序。
空间复杂度，堆排序是原地排序。快排如果考虑递归栈的话是logN，归并至少是o(N).
时间复杂度,归并排序最好最差平均都是nlogn，堆排序的平均最好最差也是nlogn，快排平均和最好都是nlogn，最差时间复杂度是n方
堆排序
in-place 归并排序是什么
归并排序是适合做外排序的。 在 i，j两个下标之后的数组中的数据没必要都读进内存中。外排序通常将中间结果放在读写较慢的外存储器上（通常是硬盘），外排序通常采用“排序——归并”的策略。排序阶段，读入能放在内存中的数据量，将其排序输出到临时文件，依次进行，将待排序数据组织为多个有序的临时文件。归并阶段，将这些临时文件组合为大的有序文件。
快速排序和堆排序是要求数据必须在内存当中的。
外排序举例，100M内存来给900M数据排序。（归并排序中，排序的部分其实不一定非得用归并排序去递归，用其他排序算法也可以。（比如堆排序））。9路归并排序的code写一下
map－reduce的思路是什么
逆序数问题，求出逆序数对数和逆序对都是什么。n方的写法是基本写法。nlogn的写法，有个对偶写法，都写一下。
杨氏矩阵的增删查改，只要行列都是有序的就行，不一定非得都是生序。插入：教材的写法是让数据形成一个上三角矩阵。查找的时候可以把数据定义在左下角或者右上角（这是对于行列都是生序的杨氏矩阵的）。删除是插入的反过程。改的话，是先给这个元素删了，然后再插入要改成的那个元素。
迷离傍地走，4个进程，两个cpu，怎么安排这四个进程的使用顺序，使这四个进程完成的时间最短。使用贪心法就可以。这是两个pipeline的进程调度问题。
寻找和为定值的两个数字，暴力解法和稍微好一点的解法。2-sum问题。
3-sum问题。用sum－a［i］，然后剩下的n－1的元素找两个元素的和是a［i］，变成了2-sum问题。
N－sum问题。取出若干个值，它们的和是定值。code在数组那次的附录里。用Hash。
在实际当中，要想查找某一个值在哪，就是用hash，是最简单的方法。hash的缺点就是空间复杂度，但是空间复杂度不在乎了。
